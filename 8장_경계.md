# 8장 경계

## 8.1 외부 코드 사용하기
```java
//Sensor라는 객체를 담는 Map이다
//의도가 분명히 드러나지 않고 깨끗하지 못한 코드다
Map sensors = new HashMap();
Sensor s = (Sensor) sensors.get(sensorId);
```

```java
//제네릭을 사용하여 가독성을 높였지만 Map인터페이스가 변할 경우 수정할 코드가 많아진다.
Map<String, Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId);
```

```java
//Map을 Sensors 안으로 숨겨 Map 인터페이스가 변하더라도 나머지 프로그램에 영향을 미치지 않는다.
public class Sensor {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
```

* Map 클래스를 사용할 때마다 위와 같이 캡슐화하라는 소리가 아니다. Map을 여기저기 넘기지 말고 Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

## 8.2 경계 살피고 익히기
* 외부 코드는 익히기 어렵다. 외부 코드를 통합하기도 어렵다 그렇기 때문에 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익혀야 하는데 이를 학습 테스트라 부른다.
> 학습 테스트란 테스트 코드를 작성하여 외부 api를 익히는 방법이다

## 8.3 학습 테스트는 공짜 이상이다
* 학습 테스트는 투자하는 노력보다 얻는 성과가 더 크다\
실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.

## 8.4 아직 존재하지 않는 코드를 사용하기
* 아는 코드와 모르는 코드를 분리\
구현을 뒤로 미루고 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제할 수 있고 코드 가독성을 높이며 코드의도도 분명해진다.

## 8.5 깨끗한 경계
* 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 이쪽 코드에서 외부 패키지를 세세하게 알아야 할 필요가 없다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.\
외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
 
